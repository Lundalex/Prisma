// Create shadows   
#pragma kernel CreateShadowsVertical
#pragma kernel CreateShadowsDiagonal
#pragma kernel CreateShadowsDirectional
// Downsample full-res shadow to low-res working grid
#pragma kernel DownsampleShadowMask
// Blur shadows
#pragma kernel CopySharpShadows
#pragma kernel BlurShadowsGaussian
#pragma kernel BlurShadowsBox
// Apply shadows (or without)
#pragma kernel ApplySharpShadows
#pragma kernel ApplyBlurredShadows
#pragma kernel ApplyWithoutShadows
// Anti-aliasing
#pragma kernel ApplyAA
#pragma kernel CopyResultToPP

#pragma multi_compile _ APPLY_RIM_LIGHTING

#include "./Helpers/MathResources.hlsl"
#include "./Helpers/DataTypes.hlsl"
#include "./Helpers/Constants.hlsl"

// ---------------------------
// Constants & uniforms
// ---------------------------

// Shadow optics
const float ShadowDarkness;
const float ShadowFalloff;  // per-1px (full-res) falloff

// Full-resolution output (Result/PPResult) resolution
const uint2 Resolution;

// Low-resolution shadow working resolution (depends on downsample factor)
const uint2 ShadowResolution;
const int   ShadowDownsampleFactor;

// Directional shadows
const float2 ShadowDirection;

// Blur settings
const int   ShadowBlurRadius;
const float ShadowDiffusion;
const int   BlurOffset;

// Rim shading
const int   CastedShadowType;
const float RimShadingStrength;
const float RimShadingBleed;
const float RimShadingOpaqueBleed;

// Anti-aliasing
const float AAThreshold;
const float AAMaxBlend;

// Global brightness factor
const float GlobalBrightnessFactor;
const float4 GlobalBrightness;

// Slow motion vignette
static const float VignetteLerpFactor = 1.0;
static const float VignetteSizeNormalized = 0.1;
static const float VignetteStrength = 0.3;

// Static settings
static const bool DO_APPLY_SHADOWS_TO_SPRINGS = true;

// ---------------------------
// Textures
// ---------------------------
Texture2D<unorm float4> Result;
RWTexture2D<unorm float4> PPResult;

// AA
Texture2D<unorm float4> AAInput;
RWTexture2D<unorm float4> AAOutput;

// ---------------------------
// Buffers
// ---------------------------

// Ping-pong flag for blur
const bool StepBufferCycle;

// Full-resolution source shadow (written by the render shader)
StructuredBuffer<float> ShadowSrcFullRes;

// Low-resolution working buffers
RWStructuredBuffer<float> ShadowMask_dbA;
RWStructuredBuffer<float> ShadowMask_dbB;
RWStructuredBuffer<float> SharpShadowMask;
RWStructuredBuffer<float> ShadowDstMask;
RWStructuredBuffer<float> RimLightMask;

// ---------------------------
// Helpers & small constants
// ---------------------------

static const int RimEarlyOpaquePixels = 5;
static const float RimEarlyOpaqueThreshold = 0.001;

uint GetPixelKeyFull(uint2 p) { return p.y * Resolution.x + p.x; }
uint GetPixelKeyLow (uint2 p) { return p.y * ShadowResolution.x + p.x; }

bool IsOutsideFullDims(uint2 p) { return p.x >= Resolution.x || p.y >= Resolution.y; }
bool IsOutsideLowDims (uint2 p) { return p.x >= ShadowResolution.x || p.y >= ShadowResolution.y; }

float2 ClampToLowGrid(float2 pos) { return clamp(pos, float2(-0.5, -0.5), float2(ShadowResolution) - 0.5); }
int2   ClampToLowCoord(int2 p)    { return clamp(p, int2(0,0), int2(ShadowResolution) - 1); }

// ---------------------------
// Slow motion vignette
// ---------------------------

float VignetteFactor(uint2 px)
{
    if (VignetteLerpFactor == 0.0) return 1.0;

    float border = (float)min(Resolution.x, Resolution.y) * 0.1;
    float2 p = (float2)px + 0.5;
    float2 toEdges = min(p, (float2)Resolution - p);
    float minEdge = min(toEdges.x, toEdges.y);
    float t = saturate(minEdge / border);
    t = smoothstep(0.0, 1.0, t);
    float strength = 0.3;
    float v = lerp(1.0 - strength, 1.0, t);
    return v * 0.8;
}

// ---------------------------
// Shadow accumulation helpers
// ---------------------------

float UpdateCarryScaled(inout float carry, float pixelShadowScaled, float stepFalloff)
{
    float newCarry   = saturate(carry * (1.0 - stepFalloff) + pixelShadowScaled);
    float carryDelta = newCarry - carry;
    carry = newCarry;
    return carryDelta;
}

#ifdef APPLY_RIM_LIGHTING
float UpdateRimCarryScaled(inout float rimTau, float pixelShadow, bool outsideRB, bool insideSpring,
                           float stepFalloff, float stepScale)
{
    float rimInput;
    if (outsideRB && !insideSpring)
    {
        rimInput = saturate(pixelShadow / max(1e-6, RimShadingBleed));
    }
    else
    {
        rimInput = min(pixelShadow, max(0.0, 1.0 / max(1e-6, RimShadingOpaqueBleed)));
    }

    rimInput *= stepScale;

    float oldTau = rimTau;
    float newTau = max(rimTau * (1.0 - stepFalloff) + rimInput, 0.0);
    rimTau = newTau;

    float Tprev       = exp(-oldTau);
    float Tnew        = exp(-newTau);
    float rimDeltaExp = max(Tprev - Tnew, 0.0);
    return rimDeltaExp;
}
#endif

void ComputeStepParams(float stepLenLow, out float stepScale, out float stepFalloff)
{
    stepScale = max(1.0, (float)ShadowDownsampleFactor) * stepLenLow;
    float baseFalloff = 1.0 - saturate(ShadowFalloff);
    stepFalloff = 1.0 - pow(baseFalloff, stepScale);
}

inline void ShadowStep(uint2 pLow,
                       inout float carry,
                       inout float rimCarry,
                       inout float dst,
                       inout bool  suppressRim,
                       uint        stepsSinceReset,
                       float       stepScale,
                       float       stepFalloff)
{
    uint idx = GetPixelKeyLow(pLow);
    float pixelShadow = ShadowMask_dbA[idx];

    bool outsideRB = (pixelShadow < 1.0 - 1e-6);

    dst = outsideRB ? (dst + 1.0) : 0.0;
    ShadowDstMask[idx] = dst;

    bool opaqueHit = pixelShadow > RimEarlyOpaqueThreshold;
    if (stepsSinceReset < (uint)RimEarlyOpaquePixels && opaqueHit) suppressRim = true;
    if (!opaqueHit) suppressRim = false;

    float pixelShadowScaled = pixelShadow * stepScale;

    UpdateCarryScaled(carry, pixelShadowScaled, stepFalloff);

    float rimOut = 0.0;
    #ifdef APPLY_RIM_LIGHTING
    {
        float rimDeltaExp = UpdateRimCarryScaled(rimCarry, pixelShadow, outsideRB, /*insideSpring=*/false,
                                                 stepFalloff, stepScale);
        rimOut = suppressRim ? 0.0 : (rimDeltaExp * RimShadingStrength);
    }
    #endif

    RimLightMask[idx] = rimOut;

    float effectiveShadow = outsideRB ? (carry * ShadowDarkness) : 0.0;
    SharpShadowMask[idx] = effectiveShadow;
}

// ---------------------------
// Downsample full-res â†’ low-res
// ---------------------------

[numthreads(TN_PP2, TN_PP2, 1)]
void DownsampleShadowMask(uint3 id : SV_DispatchThreadID)
{
    uint2 pLow = id.xy;
    if (IsOutsideLowDims(pLow)) return;

    if (ShadowDownsampleFactor == 1)
    {
        uint idxLow = GetPixelKeyLow(pLow);
        float v = ShadowSrcFullRes[GetPixelKeyFull(pLow)];

        float outv = 0.0;
        if (v < 0.0)
        {
            float mag = max(0.0, -v - 1.0);
            outv = (mag >= 1.0 - 1e-6) ? 1.0 : ((mag > 0.0) ? mag : 0.0);
        }
        else
        {
            outv = (v >= 1.0 - 1e-6) ? 1.0 : ((v > 0.0) ? v : 0.0);
        }

        ShadowMask_dbA[idxLow]  = outv;
        ShadowMask_dbB[idxLow]  = 0.0;
        SharpShadowMask[idxLow] = 0.0;
        ShadowDstMask[idxLow]   = 0.0;
        RimLightMask[idxLow]    = 0.0;
        return;
    }

    uint2 start = pLow * (uint)ShadowDownsampleFactor;
    uint2 end   = min(start + (uint2)ShadowDownsampleFactor, Resolution);

    bool  hasOpaque = false;
    float acc = 0.0;
    uint  cnt = 0u;

    for (uint y = start.y; y < end.y; ++y)
    {
        for (uint x = start.x; x < end.x; ++x)
        {
            float v = ShadowSrcFullRes[GetPixelKeyFull(uint2(x, y))];

            if (v < 0.0)
            {
                float mag = max(0.0, -v - 1.0);
                if (mag >= 1.0 - 1e-6) { hasOpaque = true; }
                else if (mag > 0.0)    { acc += mag; cnt++; }
            }
            else if (v >= 1.0 - 1e-6) { hasOpaque = true; }
            else if (v > 0.0)         { acc += v; cnt++; }

            if (hasOpaque) break;
        }
        if (hasOpaque) break;
    }

    float outv = hasOpaque ? 1.0 : ((cnt > 0u) ? (acc / cnt) : 0.0);

    uint idxLow = GetPixelKeyLow(pLow);
    ShadowMask_dbA[idxLow]  = outv;

    ShadowMask_dbB[idxLow]  = 0.0;
    SharpShadowMask[idxLow] = 0.0;
    ShadowDstMask[idxLow]   = 0.0;
    RimLightMask[idxLow]    = 0.0;
}

// ---------------------------
// Build shadows in LOW-RES
// ---------------------------

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsVertical(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    if (x >= ShadowResolution.x) return;

    float stepScale, stepFalloff;
    ComputeStepParams(/*stepLenLow=*/1.0, stepScale, stepFalloff);

    float carry = 0.0, rimCarry = 0.0, dst = LARGE_FLOAT;
    uint  stepCount = 0u; bool suppressRim = false;

    const int H = (int)ShadowResolution.y;
    for (int y = H - 1; y >= 0; --y)
    {
        ShadowStep(uint2(x, (uint)y), carry, rimCarry, dst, suppressRim, stepCount, stepScale, stepFalloff);
        stepCount++;
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDiagonal(uint3 id : SV_DispatchThreadID)
{
    uint xStart = id.x;
    if (xStart >= ShadowResolution.x) return;

    const int W = (int)ShadowResolution.x;
    const int H = (int)ShadowResolution.y;

    int x = W - 1 - (int)xStart;
    int y = H - 1;

    float stepScale, stepFalloff;
    ComputeStepParams(SQRT2, stepScale, stepFalloff);

    float carry = 0.0, rimCarry = 0.0, dst = LARGE_FLOAT;
    uint  stepCount = 0u; bool suppressRim = false;

    for (int i = 0; i < H; ++i)
    {
        if (y < 0) break;

        ShadowStep((uint2)int2(x, y), carry, rimCarry, dst, suppressRim, stepCount, stepScale, stepFalloff);

        y -= 1;
        x -= 1;
        stepCount++;

        if (x < 0)
        {
            x += W;
            carry = 0.0; rimCarry = 0.0; dst = LARGE_FLOAT;
            stepCount = 0u; suppressRim = false;
        }
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDirectional(uint3 id : SV_DispatchThreadID)
{
    const uint Wu = ShadowResolution.x;
    const uint Hu = ShadowResolution.y;
    const int  W  = (int)Wu;
    const int  H  = (int)Hu;

    float2 dir = ShadowDirection;
    if (dot(dir, dir) < EPS_DIR2) return;
    dir = normalize(dir);

    float ax = abs(dir.x), ay = abs(dir.y);
    const bool dyPos = (dir.y >= 0.0);
    const int  stepX = (dir.x >= 0.0) ?  1 : -1;
    const int  stepY =  dyPos         ?  1 : -1;

    uint x0 = id.x;
    if (x0 >= Wu) return;

    int x = (int)x0;
    int y = dyPos ? 0 : (H - 1);

    float drift = (ay > 1e-6) ? (ax / ay) : 1e6;
    float acc   = 0.0;

    float stepScale1, stepFalloff1;
    ComputeStepParams(1.0, stepScale1, stepFalloff1);
    float decay = 1.0 - stepFalloff1;

    float carry       = 0.0;
    float rimCarry    = 0.0;
    float dst         = LARGE_FLOAT;
    uint  stepCount   = 0u;
    bool  suppressRim = false;

    const uint maxIters = (uint)H;
    for (uint iter = 0; iter < maxIters; ++iter)
    {
        if (x < 0 || x >= W || y < 0 || y >= H) break;

        float carryRender = carry;

        float combinedScaled = 0.0;
        float decayPowN      = 1.0;
        uint  substeps       = 0u;

        bool wrappedThisIter = false;

        {
            uint2 p0  = uint2(x, y);
            uint  idx = GetPixelKeyLow(p0);

            float pixelShadow = ShadowMask_dbA[idx];
            bool  outsideRB   = (pixelShadow < 1.0 - 1e-6);

            dst = outsideRB ? (dst + 1.0) : 0.0;
            ShadowDstMask[idx] = dst;

            bool opaqueHit = pixelShadow > RimEarlyOpaqueThreshold;
            if (stepCount < (uint)RimEarlyOpaquePixels && opaqueHit) suppressRim = true;
            if (!opaqueHit) suppressRim = false;

            float rimTauTemp = rimCarry;
            float rimOut = 0.0;
            #ifdef APPLY_RIM_LIGHTING
            {
                float rimDeltaExp = UpdateRimCarryScaled(
                    rimTauTemp, pixelShadow, outsideRB, /*insideSpring=*/false,
                    stepFalloff1, stepScale1
                );
                rimOut = suppressRim ? 0.0 : (rimDeltaExp * RimShadingStrength);
            }
            #endif
            RimLightMask[idx] = rimOut;
            rimCarry = rimTauTemp;

            float effectiveShadow = outsideRB ? (carryRender * ShadowDarkness) : 0.0;
            SharpShadowMask[idx] = effectiveShadow;

            float pScaled = pixelShadow * stepScale1;
            combinedScaled = combinedScaled * decay + pScaled;
            decayPowN     *= decay;
            substeps      += 1u;
            stepCount     += 1u;
        }

        y += stepY;
        if (y < 0 || y >= H) break;

        acc += drift;
        if (acc >= 1.0)
        {
            int steps = (int)floor(acc);
            acc -= steps;

            for (int s = 0; s < steps; ++s)
            {
                int xPrev = x;
                x += stepX;

                bool didWrap = false;
                if (x < 0)  { x += W; didWrap = true; }
                if (x >= W) { x -= W; didWrap = true; }

                if (didWrap)
                {
                    wrappedThisIter = true;
                    break;
                }

                uint2 pD  = uint2(x, y);
                uint  idxD = GetPixelKeyLow(pD);

                float pixelShadowD = ShadowMask_dbA[idxD];
                bool  outsideRBD   = (pixelShadowD < 1.0 - 1e-6);

                dst = outsideRBD ? (dst + 1.0) : 0.0;
                ShadowDstMask[idxD] = dst;

                bool opaqueHitD = pixelShadowD > RimEarlyOpaqueThreshold;
                if (stepCount < (uint)RimEarlyOpaquePixels && opaqueHitD) suppressRim = true;
                if (!opaqueHitD) suppressRim = false;

                float rimTauTempD = rimCarry;
                float rimOutD = 0.0;
                #ifdef APPLY_RIM_LIGHTING
                {
                    float rimDeltaExpD = UpdateRimCarryScaled(
                        rimTauTempD, pixelShadowD, outsideRBD, /*insideSpring=*/false,
                        stepFalloff1, stepScale1
                    );
                    rimOutD = suppressRim ? 0.0 : (rimDeltaExpD * RimShadingStrength);
                }
                #endif
                RimLightMask[idxD] = rimOutD;
                rimCarry = rimTauTempD;

                float effectiveShadowD = outsideRBD ? (carryRender * ShadowDarkness) : 0.0;
                SharpShadowMask[idxD] = effectiveShadowD;

                float pScaledD = pixelShadowD * stepScale1;
                combinedScaled = combinedScaled * decay + pScaledD;
                decayPowN     *= decay;
                substeps      += 1u;
                stepCount     += 1u;
            }

            if (wrappedThisIter)
            {
                carry       = 0.0;
                rimCarry    = 0.0;
                dst         = LARGE_FLOAT;
                stepCount   = 0u;
                suppressRim = false;
                continue;
            }
        }

        float totalFalloff = 1.0 - decayPowN;
        UpdateCarryScaled(carry, combinedScaled, totalFalloff);
    }
}

// ---------------------------
// Post-build processing (LOW-RES)
// ---------------------------

[numthreads(TN_PP2, TN_PP2, 1)]
void CopySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideLowDims(px)) return;

    uint idx = GetPixelKeyLow(px);
    ShadowMask_dbA[idx] = SharpShadowMask[idx];
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsGaussian(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideLowDims(px)) return;

    uint idx = GetPixelKeyLow(px);

    float invRadiusSqr = 1.0 / sqr(max(1, ShadowBlurRadius));
    float minDim = (float)min(ShadowResolution.x, ShadowResolution.y);

    float centerDst = ShadowDstMask[idx];
    float softness  = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum = 0.0;
    float wsum = 0.0;

    for (int dy = -ShadowBlurRadius; dy <= ShadowBlurRadius; ++dy)
    {
        for (int dx = -ShadowBlurRadius; dx <= ShadowBlurRadius; ++dx)
        {
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)ShadowResolution.x - 1));
            qy = max(0, min(qy, (int)ShadowResolution.y - 1));

            uint idx_n = GetPixelKeyLow(uint2(qx, qy));

            float d2   = (float)(dx * dx + dy * dy);
            float baseW = exp(-d2 * invRadiusSqr);
            float ww   = lerp((dx == 0 && dy == 0) ? 1.0 : 0.0,
                              baseW,
                              min(softness, saturate((ShadowDstMask[idx_n] / minDim) * ShadowDiffusion)));

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float outv = (wsum > 0.0) ? (sum / wsum) : 0.0;
    if (StepBufferCycle) ShadowMask_dbB[idx] = outv; else ShadowMask_dbA[idx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsBox(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideLowDims(px)) return;

    int r = max(1, ShadowBlurRadius);
    float minDim = (float)min(ShadowResolution.x, ShadowResolution.y);

    uint centerIdx = GetPixelKeyLow(px);
    float centerDst = ShadowDstMask[centerIdx];
    float softC     = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum  = 0.0;
    float wsum = 0.0;

    for (int dy = -r; dy <= r; ++dy)
    {
        for (int dx = -r; dx <= r; ++dx)
        {
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)ShadowResolution.x - 1));
            qy = max(0, min(qy, (int)ShadowResolution.y - 1));

            uint idx_n = GetPixelKeyLow(uint2(qx, qy));

            float softN     = saturate((ShadowDstMask[idx_n] / minDim) * ShadowDiffusion);
            float jointSoft = min(softC, softN);

            float baseW     = 1.0;
            float centerOnly = (dx == 0 && dy == 0) ? 1.0 : 0.0;
            float ww        = lerp(centerOnly, baseW, jointSoft);

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float centerVal = StepBufferCycle ? ShadowMask_dbA[centerIdx] : ShadowMask_dbB[centerIdx];
    float outv      = (wsum > 0.0) ? (sum / wsum) : centerVal;

    if (StepBufferCycle) ShadowMask_dbB[centerIdx] = outv; else ShadowMask_dbA[centerIdx] = outv;
}

// ---------------------------
// Generic bilinear sampling from low-res buffers
// ---------------------------
static const uint BUF_A     = 0u;
static const uint BUF_B     = 1u;
static const uint BUF_SHARP = 2u;
static const uint BUF_RIM   = 3u;

float ReadLow(uint2 p, uint kind)
{
    uint idx = GetPixelKeyLow(p);
    switch (kind)
    {
        case BUF_A:     return ShadowMask_dbA[idx];
        case BUF_B:     return ShadowMask_dbB[idx];
        case BUF_SHARP: return SharpShadowMask[idx];
        case BUF_RIM:   return RimLightMask[idx];
        default:        return 0.0;
    }
}

float bilinearSampleLow(float2 lowPos, uint kind)
{
    lowPos = ClampToLowGrid(lowPos);

    int2 p0 = (int2)floor(lowPos);
    float2 f = frac(lowPos);

    int2 p1 = p0 + int2(1, 0);
    int2 p2 = p0 + int2(0, 1);
    int2 p3 = p0 + int2(1, 1);

    p0 = ClampToLowCoord(p0);
    p1 = ClampToLowCoord(p1);
    p2 = ClampToLowCoord(p2);
    p3 = ClampToLowCoord(p3);

    float s00 = ReadLow((uint2)p0, kind);
    float s10 = ReadLow((uint2)p1, kind);
    float s01 = ReadLow((uint2)p2, kind);
    float s11 = ReadLow((uint2)p3, kind);

    float sx0 = lerp(s00, s10, f.x);
    float sx1 = lerp(s01, s11, f.x);
    return lerp(sx0, sx1, f.y);
}

float bilinearSampleLow_NoRB(float2 lowPos, uint kind)
{
    lowPos = ClampToLowGrid(lowPos);

    int2 p0 = (int2)floor(lowPos);
    float2 f = frac(lowPos);

    int2 p1 = p0 + int2(1, 0);
    int2 p2 = p0 + int2(0, 1);
    int2 p3 = p0 + int2(1, 1);

    p0 = ClampToLowCoord(p0);
    p1 = ClampToLowCoord(p1);
    p2 = ClampToLowCoord(p2);
    p3 = ClampToLowCoord(p3);

    uint i00 = GetPixelKeyLow((uint2)p0);
    uint i10 = GetPixelKeyLow((uint2)p1);
    uint i01 = GetPixelKeyLow((uint2)p2);
    uint i11 = GetPixelKeyLow((uint2)p3);

    // RB interior cells have ShadowDstMask == 0
    float isRB00 = (ShadowDstMask[i00] <= 1e-6) ? 1.0 : 0.0;
    float isRB10 = (ShadowDstMask[i10] <= 1e-6) ? 1.0 : 0.0;
    float isRB01 = (ShadowDstMask[i01] <= 1e-6) ? 1.0 : 0.0;
    float isRB11 = (ShadowDstMask[i11] <= 1e-6) ? 1.0 : 0.0;

    float s00 = ReadLow((uint2)p0, kind);
    float s10 = ReadLow((uint2)p1, kind);
    float s01 = ReadLow((uint2)p2, kind);
    float s11 = ReadLow((uint2)p3, kind);

    // Standard bilinear weights
    float w00 = (1.0 - f.x) * (1.0 - f.y);
    float w10 = (       f.x) * (1.0 - f.y);
    float w01 = (1.0 - f.x) * (       f.y);
    float w11 = (       f.x) * (       f.y);

    // Zero contributions from RB interior low-res texels, then renormalize
    w00 *= (1.0 - isRB00);
    w10 *= (1.0 - isRB10);
    w01 *= (1.0 - isRB01);
    w11 *= (1.0 - isRB11);

    float wsum = w00 + w10 + w01 + w11;

    if (wsum > 1e-6)
    {
        float num = s00 * w00 + s10 * w10 + s01 * w01 + s11 * w11;
        return num / wsum;
    }
    else
    {
        // Fallback: all four are RB interior (we're sampling inside an RB)
        // return 0 so no shadow is applied; caller also clamps for RB pixels.
        return 0.0;
    }
}

float2 fullPxToLowPos(uint2 pxFull)
{
    float2 scale = (float2)ShadowResolution / (float2)Resolution;
    return ((float2)pxFull + 0.5) * scale - 0.5;
}

// ---------------------------
// Apply to FULL-RES output
// ---------------------------

inline void ApplyCommon(uint2 px, float2 lowPos, float shadow)
{
    float sFull = ShadowSrcFullRes[GetPixelKeyFull(px)];
    bool insideSpringFull   = (sFull < 0.0);
    bool insideFluidGasFull = (sFull > 0.0) && (sFull < 1.0 - 1e-6);
    bool insideRBFull       = (sFull >= 1.0 - 1e-6);
    if (insideRBFull) shadow = 0.0;

    float light = 1.0 - shadow;

    bool allowRimHere       = !insideSpringFull && (insideFluidGasFull || insideRBFull);

    float rim = 0.0;
    #ifdef APPLY_RIM_LIGHTING
    if (allowRimHere)
    {
        rim = bilinearSampleLow(lowPos, BUF_RIM);
    }
    #endif

    float4 src  = Result[px];
    float3 base = src.rgb;
    if (!insideSpringFull || DO_APPLY_SHADOWS_TO_SPRINGS) base *= light;

    float3 combinedCol = saturate(base + rim);
    PPResult[px] = float4(combinedCol, src.a);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideFullDims(px)) return;

    float2 lowPos = fullPxToLowPos(px);
    float shadow  = bilinearSampleLow_NoRB(lowPos, BUF_SHARP);
    ApplyCommon(px, lowPos, shadow);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyBlurredShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideFullDims(px)) return;

    float2 lowPos = fullPxToLowPos(px);
    uint   buf    = StepBufferCycle ? BUF_B : BUF_A;
    float  shadow = bilinearSampleLow_NoRB(lowPos, buf);
    ApplyCommon(px, lowPos, shadow);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyWithoutShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideFullDims(px)) return;
    PPResult[px] = Result[px];
}

// ---------------------------
// Anti-aliasing
// ---------------------------

static const float3 LUMA = float3(0.299, 0.587, 0.114);

float3 ReadAA_rgb(int2 p)
{
    p.x = clamp(p.x, 0, (int)Resolution.x - 1);
    p.y = clamp(p.y, 0, (int)Resolution.y - 1);
    return AAInput.Load(int3(p,0)).rgb;
}

float  ReadAA_a(int2 p)
{
    p.x = clamp(p.x, 0, (int)Resolution.x - 1);
    p.y = clamp(p.y, 0, (int)Resolution.y - 1);
    return AAInput.Load(int3(p,0)).a;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyAA(uint3 id : SV_DispatchThreadID)
{
    uint2 upx = id.xy;
    if (IsOutsideFullDims(upx)) return;

    int2 p = int2(upx);

    float3 c  = ReadAA_rgb(p);
    float3 cN = ReadAA_rgb(int2(p.x, p.y - 1));
    float3 cS = ReadAA_rgb(int2(p.x, p.y + 1));
    float3 cW = ReadAA_rgb(int2(p.x - 1, p.y));
    float3 cE = ReadAA_rgb(int2(p.x + 1, p.y));

    float lC = dot(c , LUMA);
    float lN = dot(cN, LUMA);
    float lS = dot(cS, LUMA);
    float lW = dot(cW, LUMA);
    float lE = dot(cE, LUMA);

    float gradH = abs(lW - lE);
    float gradV = abs(lN - lS);
    float edge  = max(gradH, gradV);

    float denom = max(1e-6, 1.0 - AAThreshold);
    if (edge <= AAThreshold || AAMaxBlend <= 0.0)
    {
        float outA0 = ReadAA_a(p);
        AAOutput[upx] = float4(c, outA0);
        return;
    }

    float blend = saturate((edge - AAThreshold) / denom) * AAMaxBlend;

    float3 blurH = (cW + c + cE) * (1.0/3.0);
    float3 blurV = (cN + c + cS) * (1.0/3.0);
    float3 aaCol = (gradH > gradV) ? blurV : blurH;

    float3 outCol = lerp(c, aaCol, blend);
    float  outA   = ReadAA_a(p);

    AAOutput[upx] = float4(outCol, outA);
}

[numthreads(TN_PP2,TN_PP2,1)]
void CopyResultToPP(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    float4 c = saturate(Result[id.xy]);
    PPResult[id.xy] = c * GlobalBrightness * GlobalBrightnessFactor * VignetteFactor(id.xy);
}