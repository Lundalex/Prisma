// Create shadows
#pragma kernel CreateShadowsVertical
#pragma kernel CreateShadowsDiagonal
#pragma kernel CreateShadowsDirectional
// Blur shadows
#pragma kernel CopySharpShadows
#pragma kernel BlurShadowGaussian
#pragma kernel BlurShadowsBox
// Apply shadows
#pragma kernel ApplyShadows

#include "./Helpers/MathResources.hlsl"
#include "./Helpers/DataTypes.hlsl"
#include "./Helpers/Constants.hlsl"

// Post processing
const float ShadowDarkness;
const float ShadowFalloff;

// Other
const uint2 Resolution;
const float2 ShadowDirection;

// Textures
Texture2D<unorm float4> Result;
RWTexture2D<unorm float4> PPResult;

// Buffers
const bool StepBufferCycle;
RWStructuredBuffer<float> ShadowMask_dbA;
RWStructuredBuffer<float> ShadowMask_dbB;
RWStructuredBuffer<float> SharpShadowMask;

uint GetPixelKey(uint2 threadID)
{
    return threadID.y * Resolution.x + threadID.x;
}

bool IsOutsideResolutionDims(uint2 threadID)
{
    return threadID.x > Resolution.x || threadID.y > Resolution.y;
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsVertical(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    if (x >= Resolution.x) return;

    float carry = 0.0;

    for (int y = (int)Resolution.y - 1; y >= 0; --y)
    {
        float pixelShadow = ShadowMask_dbA[GetPixelKey(uint2(x, y))];

        bool insideSpring = (pixelShadow < 0.0);
        if (insideSpring) pixelShadow += 3.0;

        bool outsideRB = (pixelShadow < 1.0 - 1e-6);

        carry = clamp(carry * (1.0 - ShadowFalloff) + pixelShadow, 0.0, 1.0);

        float effectiveShadow = (outsideRB && !insideSpring) ? (carry * ShadowDarkness) : 0.0;

        SharpShadowMask[GetPixelKey(uint2(x, y))] = effectiveShadow;
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDiagonal(uint3 id : SV_DispatchThreadID)
{
    uint xStart = id.x;
    if (xStart >= Resolution.x) return;

    const int W = (int)Resolution.x;
    const int H = (int)Resolution.y;

    int x = W - 1 - (int)xStart;
    int y = H - 1;

    float carry = 0.0;

    for (int i = 0; i < H; ++i)
    {
        uint2 up = (uint2)int2(x, y);

        float pixelShadow  = ShadowMask_dbA[GetPixelKey(up)];
        bool  insideSpring = (pixelShadow < 0.0);
        if (insideSpring) pixelShadow += 3.0;
        bool  outsideRB    = (pixelShadow < 1.0 - 1e-6);

        carry = clamp(carry * (1.0 - ShadowFalloff) + pixelShadow, 0.0, 1.0);

        float effectiveShadow = (outsideRB && !insideSpring) ? (carry * ShadowDarkness) : 0.0;

        SharpShadowMask[GetPixelKey(up)] = effectiveShadow;

        y -= 1;
        x -= 1;
        if (x < 0) { x += W; carry = 0.0; }

        if (y < 0) break;
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDirectional(uint3 id : SV_DispatchThreadID)
{
    const uint W = Resolution.x;
    const uint H = Resolution.y;

    float2 dir = ShadowDirection;
    if (all(dir == 0.0)) return;
    dir = normalize(dir);
    float ax0 = abs(dir.x), ay0 = abs(dir.y);
    if (ax0 > ay0)
    {
        dir.x = copysign(ay0, dir.x);
        dir = normalize(dir);
        ax0 = abs(dir.x); ay0 = abs(dir.y);
    }

    const bool dyPos = (dir.y >= 0.0);
    const int  stepX = (dir.x >= 0.0) ?  1 : -1;
    const int  stepY =  dyPos         ?  1 : -1;

    uint x0 = id.x;
    if (x0 >= Resolution.x) return;

    int x = (int)x0;
    int y = dyPos ? 0 : (H - 1);

    const float drift = (ay0 > 1e-6) ? (ax0 / ay0) : 0.0;
    float acc = 0.0;

    float carry = 0.0;

    const uint maxIters = (uint)H;

    for (uint i = 0; i < maxIters; ++i)
    {
        uint2 up = (uint2)int2(x, y);

        float pixelShadow = ShadowMask_dbA[GetPixelKey(up)];
        bool  insideSpring = (pixelShadow < 0.0);
        if (insideSpring) pixelShadow += 3.0;
        bool  outsideRB    = (pixelShadow < 1.0 - 1e-6);

        carry = clamp(carry * (1.0 - ShadowFalloff) + pixelShadow, 0.0, 1.0);

        float effectiveShadow = (outsideRB && !insideSpring) ? (carry * ShadowDarkness) : 0.0;

        SharpShadowMask[GetPixelKey(up)] = effectiveShadow;

        y += stepY;
        if (y < 0 || y >= (int)H) break;

        acc += drift;
        if (acc >= 1.0)
        {
            int steps = (int)floor(acc);
            acc -= steps;

            x += stepX * steps;

            bool wrapped = false;
            if (x < 0)               { x = (x % W + W) % W; wrapped = true; }
            else if (x >= (int)W)    { x = x % W;                   wrapped = true; }

            if (wrapped) carry = 0.0;
        }
    }
}

[numthreads(TN_PP2, TN_PP2, 1)]
void CopySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (px.x >= Resolution.x || px.y >= Resolution.y) return;

    uint idx = GetPixelKey(px);
    ShadowMask_dbA[idx] = SharpShadowMask[idx];
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowGaussian(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (px.x >= Resolution.x || px.y >= Resolution.y) return;

    const int R = 2;
    static const float w[5] = {1.0, 4.0, 6.0, 4.0, 1.0};

    float sum = 0.0;
    float wsum = 0.0;

    for (int dy = -R; dy <= R; ++dy)
    {
        for (int dx = -R; dx <= R; ++dx)
        {
            int qx = (int)px.x + dx; if (qx < 0) qx += (int)Resolution.x; else if (qx >= (int)Resolution.x) qx -= (int)Resolution.x;
            int qy = (int)px.y + dy; if (qy < 0) qy += (int)Resolution.y; else if (qy >= (int)Resolution.y) qy -= (int)Resolution.y;

            uint2 q = uint2(qx, qy);
            float ww = w[dx + R] * w[dy + R];
            float s  = StepBufferCycle ? ShadowMask_dbA[GetPixelKey(q)] : ShadowMask_dbB[GetPixelKey(q)];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float outv = sum / max(wsum, 1e-6);
    uint idx = GetPixelKey(px);
    if (StepBufferCycle) ShadowMask_dbB[idx] = outv; else ShadowMask_dbA[idx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsBox(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (px.x >= Resolution.x || px.y >= Resolution.y) return;

    const int R = 3;

    float sum = 0.0;
    int count = 0;

    for (int dy = -R; dy <= R; ++dy)
    {
        for (int dx = -R; dx <= R; ++dx)
        {
            int qx = (int)px.x + dx; if (qx < 0) qx += (int)Resolution.x; else if (qx >= (int)Resolution.x) qx -= (int)Resolution.x;
            int qy = (int)px.y + dy; if (qy < 0) qy += (int)Resolution.y; else if (qy >= (int)Resolution.y) qy -= (int)Resolution.y;

            uint2 q = uint2(qx, qy);
            float s = StepBufferCycle ? ShadowMask_dbA[GetPixelKey(q)] : ShadowMask_dbB[GetPixelKey(q)];
            sum += s;
            count++;
        }
    }

    float outv = sum / max((float)count, 1e-6);
    uint idx = GetPixelKey(px);
    if (StepBufferCycle) ShadowMask_dbB[idx] = outv; else ShadowMask_dbA[idx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (px.x >= Resolution.x || px.y >= Resolution.y) return;

    float shadow = SharpShadowMask[GetPixelKey(px)];
    float light = 1.0 - shadow;
    float4 src  = Result[px];
    PPResult[px] = float4(src.rgb * light, src.a);
}


// TODO:
// 1. Add blurring
// 2. Optimise shader (perhaps by implementing mip-mapping in sme way. Especially non-noticable if blur is high) (PROFILER TIME/FRAMETIME: ~20% for diagonal, 29% for directional)
// 3. Add rim lighting (separate shader). Rim data is fed by the CreateShadow kernels, to an int2-Buffer of length (2*renderTexture.width - half for rim lighting coords, half for the rim darkening coords)

// 4. For other shaders (not shadows), make new SHADERS, not KERNELS. Then, RENAME PostProcessor