// Create shadows 
#pragma kernel CreateShadowsVertical
#pragma kernel CreateShadowsDiagonal
#pragma kernel CreateShadowsDirectional
// Blur shadows
#pragma kernel CopySharpShadows
#pragma kernel BlurShadowsGaussian
#pragma kernel BlurShadowsBox
// Apply shadows (or without)
#pragma kernel ApplySharpShadows
#pragma kernel ApplyBlurredShadows
#pragma kernel ApplyWithoutShadows

#include "./Helpers/MathResources.hlsl"
#include "./Helpers/DataTypes.hlsl"
#include "./Helpers/Constants.hlsl"

// Post processing
const float ShadowDarkness;
const float ShadowFalloff;

// Other
const uint2 Resolution;
const float2 ShadowDirection;
const int ShadowBlurRadius;
const float ShadowDiffusion;
const int BlurOffset;

const int CastedShadowType;
const float RimShadingStrength;
const float RimShadingBleed;
const float RimShadingOpaqueBleed;

// Textures
Texture2D<unorm float4> Result;
RWTexture2D<unorm float4> PPResult;

// Buffers
const bool StepBufferCycle;
RWStructuredBuffer<float> ShadowMask_dbA;
RWStructuredBuffer<float> ShadowMask_dbB;
RWStructuredBuffer<float> SharpShadowMask;
RWStructuredBuffer<float> ShadowDstMask;
RWStructuredBuffer<float> RimLightMask;

static const int RimEarlyOpaquePixels = 2;

uint GetPixelKey(uint2 threadID)
{
    return threadID.y * Resolution.x + threadID.x;
}

bool IsOutsideResolutionDims(uint2 threadID)
{
    return threadID.x >= Resolution.x || threadID.y >= Resolution.y;
}

// --- Carry helper (kept in [0,1]) ---
float UpdateCarry(inout float carry, float pixelShadow) // (carryDelta)
{
    float newCarry = saturate(carry * (1.0 - ShadowFalloff) + pixelShadow);
    float carryDelta = newCarry - carry;
    carry = newCarry;
    
    return carryDelta;
}

// Parallel rim-carry (optical thickness τ) with exponential falloff.
// For fluids/gases (0..1) scale by RimShadingBleed.
// For opaque (rigid/spring), cap per-pixel thickness by RimShadingOpaqueBleed to allow controlled bleed.
float UpdateRimCarry(inout float rimTau, float pixelShadow, bool outsideRB, bool insideSpring)
{
    float rimInput;
    if (outsideRB && !insideSpring)
    {
        // Liquids/gases: control depth with RimShadingBleed (acts like a divisor/multiplier knob)
        rimInput = saturate(pixelShadow / max(1e-6, RimShadingBleed));
    }
    else
    {
        // Opaque: cap how much rim "consumption" can happen per step
        rimInput = min(pixelShadow, max(0.0, 1.0 / max(1e-6, RimShadingOpaqueBleed)));
    }

    float oldTau = rimTau;
    float newTau = max(rimTau * (1.0 - ShadowFalloff) + rimInput, 0.0);
    rimTau = newTau;

    // Beer-Lambert: T = exp(-tau). Rim contribution is the drop in transmittance this step.
    float Tprev = exp(-oldTau);
    float Tnew  = exp(-newTau);
    float rimDeltaExp = max(Tprev - Tnew, 0.0);
    return rimDeltaExp;
}

// -----------------------------------------------------------------------------
// Shared middle function: performs the per-pixel shadow update.
// Mutates `carry`, `rimCarry` (tau) and `dst` via inout parameters.
// NEW: `suppressRim` and `stepsSinceReset` implement the "early opaque" clamp.
// -----------------------------------------------------------------------------
inline void ShadowStep(uint2 p,
                       inout float carry,
                       inout float rimCarry,
                       inout float dst,
                       inout bool suppressRim,
                       uint stepsSinceReset)
{
    uint idx = GetPixelKey(p);
    float pixelShadow = ShadowMask_dbA[idx];

    // Spring detection
    bool insideSpring = (pixelShadow < 0.0);
    if (insideSpring) pixelShadow += 3.0;

    // Rigid body detection (RB encoded with value >= 1)
    bool outsideRB = (pixelShadow < 1.0 - 1e-6);

    // Determine the shadow dst
    dst = outsideRB ? (dst + 1.0) : 0.0;
    ShadowDstMask[idx] = insideSpring ? 0.0 : dst;

    // Detect an early opaque hit (within the first N steps after start/reset)
    bool opaqueHit = (!outsideRB && !insideSpring);
    if (stepsSinceReset < (uint)RimEarlyOpaquePixels && opaqueHit)
    {
        suppressRim = true;
    }
    // Leave the object: stop suppressing once we exit the opaque region
    if (!opaqueHit)
    {
        suppressRim = false;
    }

    // Update carries
    UpdateCarry(carry, pixelShadow);
    float rimDeltaExp = UpdateRimCarry(rimCarry, pixelShadow, outsideRB, insideSpring);

    // Output rim using exponential falloff contribution this step,
    // but zero it if we're suppressing due to an early opaque hit.
    float rimOut = suppressRim ? 0.0 : (rimDeltaExp * RimShadingStrength);
    RimLightMask[idx] = rimOut;

    float effectiveShadow = (outsideRB && !insideSpring) ? (carry * ShadowDarkness) : 0.0;
    SharpShadowMask[idx] = effectiveShadow;
}

// -----------------------------------------------------------------------------
// Kernel: Vertical
// -----------------------------------------------------------------------------
[numthreads(TN_PP1, 1, 1)]
void CreateShadowsVertical(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    if (x >= Resolution.x) return;

    float carry    = 0.0;
    float rimCarry = 0.0;
    float dst      = LARGE_FLOAT;

    // NEW: per-ray step counter and suppress flag
    uint stepCount = 0u;
    bool suppressRim = false;

    const int H = (int)Resolution.y;
    for (int y = H - 1; y >= 0; --y)
    {
        ShadowStep(uint2(x, (uint)y), carry, rimCarry, dst, suppressRim, stepCount);
        stepCount++;
    }
}

// -----------------------------------------------------------------------------
// Kernel: Diagonal (up-left, with horizontal wrap; reset state on wrap)
// -----------------------------------------------------------------------------
[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDiagonal(uint3 id : SV_DispatchThreadID)
{
    uint xStart = id.x;
    if (xStart >= Resolution.x) return;

    const int W = (int)Resolution.x;
    const int H = (int)Resolution.y;

    int x = W - 1 - (int)xStart;
    int y = H - 1;

    float carry    = 0.0;
    float rimCarry = 0.0;
    float dst      = LARGE_FLOAT;

    // NEW: per-ray step counter and suppress flag
    uint stepCount = 0u;
    bool suppressRim = false;

    for (int i = 0; i < H; ++i)
    {
        if (y < 0) break;

        ShadowStep((uint2)int2(x, y), carry, rimCarry, dst, suppressRim, stepCount);

        // march up-left
        y -= 1;
        x -= 1;
        stepCount++;

        // horizontal wrap allowed, but reset state so no cross-edge leakage
        if (x < 0)
        {
            x += W;
            carry = 0.0; rimCarry = 0.0; dst = LARGE_FLOAT;

            // NEW: reset counter and suppression on wrap
            stepCount = 0u;
            suppressRim = false;
        }
    }
}

// -----------------------------------------------------------------------------
// Kernel: Directional (arbitrary normalized direction, horizontal wrap allowed)
// -----------------------------------------------------------------------------
[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDirectional(uint3 id : SV_DispatchThreadID)
{
    const uint Wu = Resolution.x;
    const uint Hu = Resolution.y;
    const int  W  = (int)Wu;
    const int  H  = (int)Hu;

    float2 dir = ShadowDirection;
    if (all(dir == 0.0)) return;
    dir = normalize(dir);

    float ax = abs(dir.x), ay = abs(dir.y);
    const bool dyPos = (dir.y >= 0.0);
    const int  stepX = (dir.x >= 0.0) ?  1 : -1;
    const int  stepY =  dyPos         ?  1 : -1;

    uint x0 = id.x;
    if (x0 >= Wu) return;

    int x = (int)x0;
    int y = dyPos ? 0 : (H - 1);

    // robust near-horizontal drift
    float drift = (ay > 1e-6) ? (ax / ay) : 1e6;
    float acc   = 0.0;

    float carry    = 0.0;
    float rimCarry = 0.0;
    float dst      = LARGE_FLOAT;

    // NEW: per-ray step counter and suppress flag
    uint stepCount = 0u;
    bool suppressRim = false;

    const uint maxIters = (uint)H;
    for (uint i = 0; i < maxIters; ++i)
    {
        if (x < 0 || x >= W || y < 0 || y >= H) break;

        ShadowStep(uint2(x, y), carry, rimCarry, dst, suppressRim, stepCount);

        // step in primary (Y) and drift along X
        y += stepY;
        if (y < 0 || y >= H) break;

        stepCount++;

        acc += drift;
        if (acc >= 1.0)
        {
            int steps = (int)floor(acc);
            acc -= steps;

            x += stepX * steps;

            // allow horizontal wrap; reset accumulators on wrap
            bool wrapped = false;
            if (x < 0)       { x = (x % W + W) % W; wrapped = true; }
            else if (x >= W) { x = x % W;          wrapped = true; }

            if (wrapped)
            {
                carry = 0.0; rimCarry = 0.0; dst = LARGE_FLOAT;

                // NEW: reset counter and suppression on wrap
                stepCount = 0u;
                suppressRim = false;
            }
        }
    }
}

[numthreads(TN_PP2, TN_PP2, 1)]
void CopySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideResolutionDims(px)) return;

    uint idx = GetPixelKey(px);
    ShadowMask_dbA[idx] = SharpShadowMask[idx];
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsGaussian(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    uint idx = GetPixelKey(px);
    if (IsOutsideResolutionDims(px)) return;

    float invRadiusSqr = 1.0 / sqr(max(1, ShadowBlurRadius));
    float minDim = (float)min(Resolution.x, Resolution.y);

    float centerDst = ShadowDstMask[idx];
    float softness  = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum = 0.0;
    float wsum = 0.0;

    for (int dy = -ShadowBlurRadius; dy <= ShadowBlurRadius; ++dy)
    {
        for (int dx = -ShadowBlurRadius; dx <= ShadowBlurRadius; ++dx)
        {
            // Clamp — no wrap in blur
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)Resolution.x - 1));
            qy = max(0, min(qy, (int)Resolution.y - 1));

            uint idx_n = GetPixelKey(uint2(qx, qy));

            float d2 = (float)(dx * dx + dy * dy);
            float baseW = exp(-d2 * invRadiusSqr);
            float ww = lerp((dx == 0 && dy == 0) ? 1.0 : 0.0,
                            baseW,
                            min(softness, saturate((ShadowDstMask[idx_n] / minDim) * ShadowDiffusion)));

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float outv = (wsum > 0.0) ? (sum / wsum) : 0.0;
    if (StepBufferCycle) ShadowMask_dbB[idx] = outv; else ShadowMask_dbA[idx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsBox(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideResolutionDims(px)) return;

    int r = max(1, ShadowBlurRadius);
    float minDim = (float)min(Resolution.x, Resolution.y);

    uint centerIdx = GetPixelKey(px);
    float centerDst = ShadowDstMask[centerIdx];
    float softC     = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum = 0.0;
    float wsum = 0.0;

    for (int dy = -r; dy <= r; ++dy)
    {
        for (int dx = -r; dx <= r; ++dx)
        {
            // Clamp — no wrap in blur
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)Resolution.x - 1));
            qy = max(0, min(qy, (int)Resolution.y - 1));

            uint idx_n = GetPixelKey(uint2(qx, qy));

            float softN = saturate((ShadowDstMask[idx_n] / minDim) * ShadowDiffusion);
            float jointSoft = min(softC, softN);

            float baseW = 1.0; // box kernel
            float centerOnly = (dx == 0 && dy == 0) ? 1.0 : 0.0;
            float ww = lerp(centerOnly, baseW, jointSoft);

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float centerVal = StepBufferCycle ? ShadowMask_dbA[centerIdx] : ShadowMask_dbB[centerIdx];
    float outv = (wsum > 0.0) ? (sum / wsum) : centerVal;

    if (StepBufferCycle) ShadowMask_dbB[centerIdx] = outv; else ShadowMask_dbA[centerIdx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    uint idx = GetPixelKey(id.xy);
    if (IsOutsideResolutionDims(px)) return;

    float shadow = SharpShadowMask[GetPixelKey(px)];
    float light = 1.0 - shadow;
    float rimLight = RimLightMask[idx];

    float4 src  = Result[px];
    float3 combinedCol = saturate(src.rgb * light + rimLight);
    PPResult[px] = float4(combinedCol, src.a);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyBlurredShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    uint idx = GetPixelKey(id.xy);
    if (IsOutsideResolutionDims(px)) return;

    float shadow = StepBufferCycle ? ShadowMask_dbB[idx] : ShadowMask_dbA[idx];
    float light = 1.0 - shadow;
    float rimLight = RimLightMask[idx];
    if (SharpShadowMask[idx] < 0)
    {
        PPResult[px] = Result[px];
    }
    else
    {
        float4 src  = Result[px];
        float3 combinedCol = saturate(src.rgb * light + rimLight);
        PPResult[px] = float4(combinedCol, src.a);
    }
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyWithoutShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideResolutionDims(px)) return;

    PPResult[px] = Result[px];
}

// IDEA - RIMS - ADD RIM LIGHTING WHERE LIGHT IS ABSORBED. THEN, BLEED THROUGH FOR A FEW PIXELS, USING AN EXP-MODEL.
// BACKLIGHTING - ... THEN, DARKEN THE BACKSIDE (WHERE THE LIGHT RAY EXITS) SINCE THATS WHERE LIGHT EXITS
// SHADOW ABSORBTION - ... ALSO DARKEN EDGES WHERE SHADOW RAYS HIT ("ABSORBS SHADOW")