// Create shadows 
#pragma kernel CreateShadowsVertical
#pragma kernel CreateShadowsDiagonal
#pragma kernel CreateShadowsDirectional
// Blur shadows
#pragma kernel CopySharpShadows
#pragma kernel BlurShadowsGaussian
#pragma kernel BlurShadowsBox
// Apply shadows
#pragma kernel ApplySharpShadows
#pragma kernel ApplyBlurredShadows

#include "./Helpers/MathResources.hlsl"
#include "./Helpers/DataTypes.hlsl"
#include "./Helpers/Constants.hlsl"

// Post processing
const float ShadowDarkness;
const float ShadowFalloff;

// Other
const uint2 Resolution;
const float2 ShadowDirection;
const int ShadowBlurRadius;
const float ShadowDiffusion;
const int BlurOffset;

// Textures
Texture2D<unorm float4> Result;
RWTexture2D<unorm float4> PPResult;

// Buffers
const bool StepBufferCycle;
RWStructuredBuffer<float> ShadowMask_dbA;
RWStructuredBuffer<float> ShadowMask_dbB;
RWStructuredBuffer<float> SharpShadowMask;
RWStructuredBuffer<float> ShadowDstMark;

uint GetPixelKey(uint2 threadID)
{
    return threadID.y * Resolution.x + threadID.x;
}

bool IsOutsideResolutionDims(uint2 threadID)
{
    return threadID.x >= Resolution.x || threadID.y >= Resolution.y;
}

// --- Carry helper (kept in [0,1]) ---
float UpdateCarry(float carry, float pixelShadow)
{
    return saturate(carry * (1.0 - ShadowFalloff) + pixelShadow);
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsVertical(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    if (x >= Resolution.x) return;

    float carry = 0.0;
    float dst = LARGE_FLOAT;

    for (int y = (int)Resolution.y - 1; y >= 0; --y)
    {
        float pixelShadow = ShadowMask_dbA[GetPixelKey(uint2(x, y))];

        bool insideSpring = (pixelShadow < 0.0);
        if (insideSpring) pixelShadow += 3.0;

        bool outsideRB = (pixelShadow < 1.0 - 1e-6);

        dst = outsideRB ? (dst + 1.0) : 0.0;
        ShadowDstMark[GetPixelKey(uint2(x, y))] = insideSpring ? 0.0 : dst;

        carry = UpdateCarry(carry, pixelShadow);

        float effectiveShadow = (outsideRB && !insideSpring) ? (carry * ShadowDarkness) : 0.0;

        SharpShadowMask[GetPixelKey(uint2(x, y))] = effectiveShadow;
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDiagonal(uint3 id : SV_DispatchThreadID)
{
    uint xStart = id.x;
    if (xStart >= Resolution.x) return;

    const int W = (int)Resolution.x;
    const int H = (int)Resolution.y;

    int x = W - 1 - (int)xStart;
    int y = H - 1;

    float carry = 0.0;
    float dst = LARGE_FLOAT;

    for (int i = 0; i < H; ++i)
    {
        uint2 up = (uint2)int2(x, y);

        float pixelShadow  = ShadowMask_dbA[GetPixelKey(up)];
        bool  insideSpring = (pixelShadow < 0.0);
        if (insideSpring) pixelShadow += 3.0;
        bool  outsideRB    = (pixelShadow < 1.0 - 1e-6);

        dst = outsideRB ? (dst + 1.0) : 0.0;
        ShadowDstMark[GetPixelKey(up)] = insideSpring ? 0.0 : dst;

        carry = UpdateCarry(carry, pixelShadow);

        float effectiveShadow = (outsideRB && !insideSpring) ? (carry * ShadowDarkness) : 0.0;
        SharpShadowMask[GetPixelKey(up)] = effectiveShadow;

        // march up-left
        y -= 1;
        x -= 1;

        // horizontal wrap allowed, but reset state so no cross-edge leakage
        if (x < 0) { x += W; carry = 0.0; dst = LARGE_FLOAT; }

        // stop when we pass the top
        if (y < 0) break;
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDirectional(uint3 id : SV_DispatchThreadID)
{
    const uint Wu = Resolution.x;
    const uint Hu = Resolution.y;
    const int  W  = (int)Wu;
    const int  H  = (int)Hu;

    float2 dir = ShadowDirection;
    if (all(dir == 0.0)) return;
    dir = normalize(dir);

    float ax = abs(dir.x), ay = abs(dir.y);
    const bool dyPos = (dir.y >= 0.0);
    const int  stepX = (dir.x >= 0.0) ?  1 : -1;
    const int  stepY =  dyPos         ?  1 : -1;

    uint x0 = id.x;
    if (x0 >= Wu) return;

    int x = (int)x0;
    int y = dyPos ? 0 : (H - 1);

    float drift = (ay > 1e-6) ? (ax / ay) : 1e6; // robust near-horizontal
    float acc   = 0.0;

    float carry = 0.0;
    float dst   = LARGE_FLOAT;

    const uint maxIters = (uint)H;
    for (uint i = 0; i < maxIters; ++i)
    {
        if (x < 0 || x >= W || y < 0 || y >= H) break;

        uint2 up = uint2(x, y);

        float pixelShadow  = ShadowMask_dbA[GetPixelKey(up)];
        bool  insideSpring = (pixelShadow < 0.0);
        if (insideSpring) pixelShadow += 3.0;
        bool  outsideRB    = (pixelShadow < 1.0 - 1e-6);

        dst = outsideRB ? (dst + 1.0) : 0.0;
        ShadowDstMark[GetPixelKey(up)] = insideSpring ? 0.0 : dst;

        carry = UpdateCarry(carry, pixelShadow);

        float effectiveShadow = (outsideRB && !insideSpring) ? (carry * ShadowDarkness) : 0.0;
        SharpShadowMask[GetPixelKey(up)] = effectiveShadow;

        y += stepY;
        if (y < 0 || y >= H) break;

        acc += drift;
        if (acc >= 1.0)
        {
            int steps = (int)floor(acc);
            acc -= steps;

            x += stepX * steps;

            // allow horizontal wrap, but reset accumulators so edges don't share
            bool wrapped = false;
            if (x < 0)       { x = (x % W + W) % W; wrapped = true; }
            else if (x >= W) { x = x % W;          wrapped = true; }

            if (wrapped) { carry = 0.0; dst = LARGE_FLOAT; }
        }
    }
}

[numthreads(TN_PP2, TN_PP2, 1)]
void CopySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideResolutionDims(px)) return;

    uint idx = GetPixelKey(px);
    ShadowMask_dbA[idx] = SharpShadowMask[idx];
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsGaussian(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    uint idx = GetPixelKey(px);
    if (IsOutsideResolutionDims(px)) return;

    float invRadiusSqr = 1.0 / sqr(max(1, ShadowBlurRadius));
    float minDim = (float)min(Resolution.x, Resolution.y);

    float centerDst = ShadowDstMark[idx];
    float softness  = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum = 0.0;
    float wsum = 0.0;

    for (int dy = -ShadowBlurRadius; dy <= ShadowBlurRadius; ++dy)
    {
        for (int dx = -ShadowBlurRadius; dx <= ShadowBlurRadius; ++dx)
        {
            // Clamp — no wrap in blur
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)Resolution.x - 1));
            qy = max(0, min(qy, (int)Resolution.y - 1));

            uint idx_n = GetPixelKey(uint2(qx, qy));

            float d2 = (float)(dx * dx + dy * dy);
            float baseW = exp(-d2 * invRadiusSqr);
            float ww = lerp((dx == 0 && dy == 0) ? 1.0 : 0.0,
                            baseW,
                            min(softness, saturate((ShadowDstMark[idx_n] / minDim) * ShadowDiffusion)));

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float outv = (wsum > 0.0) ? (sum / wsum) : 0.0;
    if (StepBufferCycle) ShadowMask_dbB[idx] = outv; else ShadowMask_dbA[idx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsBox(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideResolutionDims(px)) return;

    int r = max(1, ShadowBlurRadius);
    float minDim = (float)min(Resolution.x, Resolution.y);

    uint centerIdx = GetPixelKey(px);
    float centerDst = ShadowDstMark[centerIdx];
    float softC     = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum = 0.0;
    float wsum = 0.0;

    for (int dy = -r; dy <= r; ++dy)
    {
        for (int dx = -r; dx <= r; ++dx)
        {
            // Clamp — no wrap in blur
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)Resolution.x - 1));
            qy = max(0, min(qy, (int)Resolution.y - 1));

            uint idx_n = GetPixelKey(uint2(qx, qy));

            float softN = saturate((ShadowDstMark[idx_n] / minDim) * ShadowDiffusion);
            float jointSoft = min(softC, softN);

            float baseW = 1.0; // box kernel
            float centerOnly = (dx == 0 && dy == 0) ? 1.0 : 0.0;
            float ww = lerp(centerOnly, baseW, jointSoft);

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float centerVal = StepBufferCycle ? ShadowMask_dbA[centerIdx] : ShadowMask_dbB[centerIdx];
    float outv = (wsum > 0.0) ? (sum / wsum) : centerVal;

    if (StepBufferCycle) ShadowMask_dbB[centerIdx] = outv; else ShadowMask_dbA[centerIdx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideResolutionDims(px)) return;

    float shadow = SharpShadowMask[GetPixelKey(px)];
    float light = 1.0 - shadow;
    float4 src  = Result[px];
    PPResult[px] = float4(src.rgb * light, src.a);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyBlurredShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    uint idx = GetPixelKey(id.xy);
    if (IsOutsideResolutionDims(px)) return;

    float shadow = StepBufferCycle ? ShadowMask_dbB[idx] : ShadowMask_dbA[idx];
    float light = 1.0 - shadow;
    if (SharpShadowMask[idx] < 0)
    {
        PPResult[px] = Result[px];
    }
    else
    {
        float4 src  = Result[px];
        PPResult[px] = float4(src.rgb * light, src.a);
    }
}

IDEA - RIMS - ADD RIM LIGHTING WHERE LIGHT IS ABSORBED. THEN, BLEED THROUGH FOR A FEW PIXELS, USING AN EXP-MODEL.
BACKLIGHTING - ... THEN, DARKEN THE BACKSIDE (WHERE THE LIGHT RAY EXITS) SINCE THATS WHERE LIGHT EXITS
SHADOW ABSORBTION - ... ALSO DARKEN EDGES WHERE SHADOW RAYS HIT ("ABSORBS SHADOW")