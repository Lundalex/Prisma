// Create shadows 
#pragma kernel CreateShadowsVertical
#pragma kernel CreateShadowsDiagonal
#pragma kernel CreateShadowsDirectional
// Downsample full-res shadow to low-res working grid
#pragma kernel DownsampleShadowMask
// Blur shadows
#pragma kernel CopySharpShadows
#pragma kernel BlurShadowsGaussian
#pragma kernel BlurShadowsBox
// Apply shadows (or without)
#pragma kernel ApplySharpShadows
#pragma kernel ApplyBlurredShadows
#pragma kernel ApplyWithoutShadows
// Anti-aliasing
#pragma kernel ApplyAA
#pragma kernel CopyResultToPP

#pragma multi_compile _ APPLY_RIM_LIGHTING

#include "./Helpers/MathResources.hlsl"
#include "./Helpers/DataTypes.hlsl"
#include "./Helpers/Constants.hlsl"

// ---------------------------
// Constants & uniforms
// ---------------------------

// Shadow optics (interpreted per *full-res* pixel length)
const float ShadowDarkness;
const float ShadowFalloff;  // per-1px (full-res) falloff

// Full-resolution output (Result/PPResult) resolution
const uint2 Resolution;

// Low-resolution shadow working resolution (depends on downsample factor)
const uint2 ShadowResolution;
const int   ShadowDownsampleFactor;

// Directional shadows
const float2 ShadowDirection;

// Blur settings
const int   ShadowBlurRadius;
const float ShadowDiffusion;
const int   BlurOffset;

// Rim shading
const int   CastedShadowType;
const float RimShadingStrength;
const float RimShadingBleed;
const float RimShadingOpaqueBleed;

// Anti-aliasing
const float AAThreshold;
const float AAMaxBlend;

// ---------------------------
// Textures
// ---------------------------
Texture2D<unorm float4> Result;
RWTexture2D<unorm float4> PPResult;

// AA I/O (bind in C#; see ShaderHelper.SetPostProcessorTextures)
Texture2D<unorm float4> AAInput;
RWTexture2D<unorm float4> AAOutput;

// ---------------------------
// Buffers
// ---------------------------

// Ping-pong flag for blur
const bool StepBufferCycle;

// Full-resolution source shadow (written by the render shader)
StructuredBuffer<float> ShadowSrcFullRes;

// Low-resolution working buffers
RWStructuredBuffer<float> ShadowMask_dbA;
RWStructuredBuffer<float> ShadowMask_dbB;
RWStructuredBuffer<float> SharpShadowMask;
RWStructuredBuffer<float> ShadowDstMask;
RWStructuredBuffer<float> RimLightMask;

// ---------------------------
// Helpers: indexing & clamps
// ---------------------------

uint GetPixelKeyFull(uint2 p) { return p.y * Resolution.x + p.x; }
uint GetPixelKeyLow (uint2 p) { return p.y * ShadowResolution.x + p.x; }

bool IsOutsideFullDims(uint2 p) { return p.x >= Resolution.x || p.y >= Resolution.y; }
bool IsOutsideLowDims (uint2 p) { return p.x >= ShadowResolution.x || p.y >= ShadowResolution.y; }

float2 ClampToLowGrid(float2 pos) { return clamp(pos, float2(-0.5, -0.5), float2(ShadowResolution) - 0.5); }
int2   ClampToLowCoord(int2 p)    { return clamp(p, int2(0,0), int2(ShadowResolution) - 1); }

// ---------------------------
// Shadow accumulation helpers
// ---------------------------

// Per-step, downsample-normalized carry update:
// stepFalloff = 1 - (1 - ShadowFalloff)^(stepLenFullRes)
// pixelShadowScaled = pixelShadow * stepLenFullRes
float UpdateCarryScaled(inout float carry, float pixelShadowScaled, float stepFalloff)
{
    float newCarry   = saturate(carry * (1.0 - stepFalloff) + pixelShadowScaled);
    float carryDelta = newCarry - carry;
    carry = newCarry;
    return carryDelta;
}

#if APPLY_RIM_LIGHTING
// Parallel rim-carry (optical thickness τ) with exponential falloff.
// Outside RB (fluids/gases), scale by RimShadingBleed.
// Opaque (rigid), cap per-pixel thickness by RimShadingOpaqueBleed.
float UpdateRimCarryScaled(inout float rimTau, float pixelShadow, bool outsideRB, bool insideSpring,
                           float stepFalloff, float stepScale)
{
    float rimInput;
    if (outsideRB && !insideSpring)
    {
        // Liquids/gases
        rimInput = saturate(pixelShadow / max(1e-6, RimShadingBleed));
    }
    else
    {
        // Opaque: limit per-step contribution
        rimInput = min(pixelShadow, max(0.0, 1.0 / max(1e-6, RimShadingOpaqueBleed)));
    }

    rimInput *= stepScale;

    float oldTau = rimTau;
    float newTau = max(rimTau * (1.0 - stepFalloff) + rimInput, 0.0);
    rimTau = newTau;

    // Beer-Lambert: rim contribution is transmittance drop this step.
    float Tprev       = exp(-oldTau);
    float Tnew        = exp(-newTau);
    float rimDeltaExp = max(Tprev - Tnew, 0.0);
    return rimDeltaExp;
}
#endif

// Common step parameters for all marching kernels.
void ComputeStepParams(float stepLenLow, out float stepScale, out float stepFalloff)
{
    stepScale   = max(1.0, (float)ShadowDownsampleFactor) * stepLenLow;
    stepFalloff = 1.0 - pow(1.0 - saturate(ShadowFalloff), stepScale);
}

// Shared middle function: per-pixel shadow update on LOW-RES grid.
inline void ShadowStep(uint2 pLow,
                       inout float carry,
                       inout float rimCarry,
                       inout float dst,
                       inout bool  suppressRim,
                       uint        stepsSinceReset,
                       float       stepScale,
                       float       stepFalloff)
{
    uint idx = GetPixelKeyLow(pLow);
    float pixelShadow = ShadowMask_dbA[idx];

    // Rigid body detection (RB encoded with value >= 1)
    bool outsideRB = (pixelShadow < 1.0 - 1e-6);

    // Distance-from-occluder in low-res steps (for blur softness)
    dst = outsideRB ? (dst + 1.0) : 0.0;
    ShadowDstMask[idx] = dst;

    // Early opaque hit suppression near the start
    static const int RimEarlyOpaquePixels = 2;
    bool opaqueHit = (!outsideRB);
    if (stepsSinceReset < (uint)RimEarlyOpaquePixels && opaqueHit) suppressRim = true;
    if (!opaqueHit) suppressRim = false; // reset once we leave opaque

    float pixelShadowScaled = pixelShadow * stepScale;

    // Update main shadow carry
    UpdateCarryScaled(carry, pixelShadowScaled, stepFalloff);

    // Optional rim carry
    float rimOut = 0.0;
    #if APPLY_RIM_LIGHTING
    {
        float rimDeltaExp = UpdateRimCarryScaled(rimCarry, pixelShadow, outsideRB, /*insideSpring=*/false,
                                                 stepFalloff, stepScale);
        rimOut = suppressRim ? 0.0 : (rimDeltaExp * RimShadingStrength);
    }
    #endif

    RimLightMask[idx] = rimOut;

    float effectiveShadow = outsideRB ? (carry * ShadowDarkness) : 0.0;
    SharpShadowMask[idx] = effectiveShadow;
}

// ---------------------------
// Downsample full-res → low-res
// ---------------------------

// Springs use encoding s = -(m + 1). Recover magnitude with max(0, -s - 1).
[numthreads(TN_PP2, TN_PP2, 1)]
void DownsampleShadowMask(uint3 id : SV_DispatchThreadID)
{
    uint2 pLow = id.xy;
    if (IsOutsideLowDims(pLow)) return;

    uint2 start = pLow * (uint)ShadowDownsampleFactor;
    uint2 end   = min(start + (uint2)ShadowDownsampleFactor, Resolution);

    bool  hasOpaque = false;
    float acc = 0.0;
    uint  cnt = 0u;

    for (uint y = start.y; y < end.y; ++y)
    {
        for (uint x = start.x; x < end.x; ++x)
        {
            float v = ShadowSrcFullRes[GetPixelKeyFull(uint2(x, y))];

            if (v < 0.0)
            {
                float mag = max(0.0, -v - 1.0);
                if (mag >= 1.0 - 1e-6) { hasOpaque = true; }
                else if (mag > 0.0)    { acc += mag; cnt++; }
            }
            else if (v >= 1.0 - 1e-6) { hasOpaque = true; }
            else if (v > 0.0)         { acc += v; cnt++; }
        }
    }

    float outv = hasOpaque ? 1.0 : ((cnt > 0u) ? (acc / cnt) : 0.0);

    uint idxLow = GetPixelKeyLow(pLow);
    ShadowMask_dbA[idxLow]  = outv;

    // Clear others
    ShadowMask_dbB[idxLow]  = 0.0;
    SharpShadowMask[idxLow] = 0.0;
    ShadowDstMask[idxLow]   = 0.0;
    RimLightMask[idxLow]    = 0.0;
}

// ---------------------------
// Build shadows in LOW-RES
// ---------------------------

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsVertical(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    if (x >= ShadowResolution.x) return;

    float stepScale, stepFalloff;
    ComputeStepParams(/*stepLenLow=*/1.0, stepScale, stepFalloff);

    float carry = 0.0, rimCarry = 0.0, dst = LARGE_FLOAT;
    uint  stepCount = 0u; bool suppressRim = false;

    const int H = (int)ShadowResolution.y;
    for (int y = H - 1; y >= 0; --y)
    {
        ShadowStep(uint2(x, (uint)y), carry, rimCarry, dst, suppressRim, stepCount, stepScale, stepFalloff);
        stepCount++;
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDiagonal(uint3 id : SV_DispatchThreadID)
{
    uint xStart = id.x;
    if (xStart >= ShadowResolution.x) return;

    const int W = (int)ShadowResolution.x;
    const int H = (int)ShadowResolution.y;

    int x = W - 1 - (int)xStart;
    int y = H - 1;

    float stepScale, stepFalloff;
    ComputeStepParams(/*stepLenLow≈√2*/1.41421356, stepScale, stepFalloff);

    float carry = 0.0, rimCarry = 0.0, dst = LARGE_FLOAT;
    uint  stepCount = 0u; bool suppressRim = false;

    for (int i = 0; i < H; ++i)
    {
        if (y < 0) break;

        ShadowStep((uint2)int2(x, y), carry, rimCarry, dst, suppressRim, stepCount, stepScale, stepFalloff);

        // march up-left
        y -= 1;
        x -= 1;
        stepCount++;

        // horizontal wrap allowed; reset state on wrap
        if (x < 0)
        {
            x += W;
            carry = 0.0; rimCarry = 0.0; dst = LARGE_FLOAT;
            stepCount = 0u; suppressRim = false;
        }
    }
}

[numthreads(TN_PP1, 1, 1)]
void CreateShadowsDirectional(uint3 id : SV_DispatchThreadID)
{
    const uint Wu = ShadowResolution.x;
    const uint Hu = ShadowResolution.y;
    const int  W  = (int)Wu;
    const int  H  = (int)Hu;

    float2 dir = ShadowDirection;
    if (all(dir == 0.0)) return;
    dir = normalize(dir);

    float ax = abs(dir.x), ay = abs(dir.y);
    const bool dyPos = (dir.y >= 0.0);
    const int  stepX = (dir.x >= 0.0) ?  1 : -1;
    const int  stepY =  dyPos         ?  1 : -1;

    uint x0 = id.x;
    if (x0 >= Wu) return;

    int x = (int)x0;
    int y = dyPos ? 0 : (H - 1);

    // robust near-horizontal drift
    float drift = (ay > 1e-6) ? (ax / ay) : 1e6;
    float acc   = 0.0;

    float stepScale, stepFalloff;
    ComputeStepParams(/*primary row step*/1.0, stepScale, stepFalloff);

    float carry = 0.0, rimCarry = 0.0, dst = LARGE_FLOAT;
    uint  stepCount = 0u; bool suppressRim = false;

    const uint maxIters = (uint)H;
    for (uint i = 0; i < maxIters; ++i)
    {
        if (x < 0 || x >= W || y < 0 || y >= H) break;

        ShadowStep(uint2(x, y), carry, rimCarry, dst, suppressRim, stepCount, stepScale, stepFalloff);

        // step in primary (Y) and drift along X
        y += stepY;
        if (y < 0 || y >= H) break;

        stepCount++;

        acc += drift;
        if (acc >= 1.0)
        {
            int steps = (int)floor(acc);
            acc -= steps;

            x += stepX * steps;

            // allow horizontal wrap; reset accumulators on wrap
            bool wrapped = false;
            if (x < 0)       { x = (x % W + W) % W; wrapped = true; }
            else if (x >= W) { x = x % W;          wrapped = true; }

            if (wrapped)
            {
                carry = 0.0; rimCarry = 0.0; dst = LARGE_FLOAT;
                stepCount = 0u; suppressRim = false;
            }
        }
    }
}

// ---------------------------
// Post-build processing (LOW-RES)
// ---------------------------

[numthreads(TN_PP2, TN_PP2, 1)]
void CopySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideLowDims(px)) return;

    uint idx = GetPixelKeyLow(px);
    ShadowMask_dbA[idx] = SharpShadowMask[idx];
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsGaussian(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideLowDims(px)) return;

    uint idx = GetPixelKeyLow(px);

    float invRadiusSqr = 1.0 / sqr(max(1, ShadowBlurRadius));
    float minDim = (float)min(ShadowResolution.x, ShadowResolution.y);

    float centerDst = ShadowDstMask[idx];
    float softness  = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum = 0.0;
    float wsum = 0.0;

    for (int dy = -ShadowBlurRadius; dy <= ShadowBlurRadius; ++dy)
    {
        for (int dx = -ShadowBlurRadius; dx <= ShadowBlurRadius; ++dx)
        {
            // Clamp — no wrap in blur
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)ShadowResolution.x - 1));
            qy = max(0, min(qy, (int)ShadowResolution.y - 1));

            uint idx_n = GetPixelKeyLow(uint2(qx, qy));

            float d2   = (float)(dx * dx + dy * dy);
            float baseW = exp(-d2 * invRadiusSqr);
            float ww   = lerp((dx == 0 && dy == 0) ? 1.0 : 0.0,
                              baseW,
                              min(softness, saturate((ShadowDstMask[idx_n] / minDim) * ShadowDiffusion)));

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float outv = (wsum > 0.0) ? (sum / wsum) : 0.0;
    if (StepBufferCycle) ShadowMask_dbB[idx] = outv; else ShadowMask_dbA[idx] = outv;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void BlurShadowsBox(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideLowDims(px)) return;

    int r = max(1, ShadowBlurRadius);
    float minDim = (float)min(ShadowResolution.x, ShadowResolution.y);

    uint centerIdx = GetPixelKeyLow(px);
    float centerDst = ShadowDstMask[centerIdx];
    float softC     = saturate((centerDst / minDim) * ShadowDiffusion);

    float sum  = 0.0;
    float wsum = 0.0;

    for (int dy = -r; dy <= r; ++dy)
    {
        for (int dx = -r; dx <= r; ++dx)
        {
            // Clamp — no wrap in blur
            int qx = (int)px.x + BlurOffset * dx;
            int qy = (int)px.y + BlurOffset * dy;
            qx = max(0, min(qx, (int)ShadowResolution.x - 1));
            qy = max(0, min(qy, (int)ShadowResolution.y - 1));

            uint idx_n = GetPixelKeyLow(uint2(qx, qy));

            float softN     = saturate((ShadowDstMask[idx_n] / minDim) * ShadowDiffusion);
            float jointSoft = min(softC, softN);

            float baseW     = 1.0; // box kernel
            float centerOnly = (dx == 0 && dy == 0) ? 1.0 : 0.0;
            float ww        = lerp(centerOnly, baseW, jointSoft);

            float s = StepBufferCycle ? ShadowMask_dbA[idx_n] : ShadowMask_dbB[idx_n];

            sum  += s * ww;
            wsum += ww;
        }
    }

    float centerVal = StepBufferCycle ? ShadowMask_dbA[centerIdx] : ShadowMask_dbB[centerIdx];
    float outv      = (wsum > 0.0) ? (sum / wsum) : centerVal;

    if (StepBufferCycle) ShadowMask_dbB[centerIdx] = outv; else ShadowMask_dbA[centerIdx] = outv;
}

// ---------------------------
// Generic bilinear sampling from low-res buffers
// ---------------------------
static const uint BUF_A     = 0u;
static const uint BUF_B     = 1u;
static const uint BUF_SHARP = 2u;
static const uint BUF_RIM   = 3u;

float ReadLow(uint2 p, uint kind)
{
    uint idx = GetPixelKeyLow(p);
    switch (kind)
    {
        case BUF_A:     return ShadowMask_dbA[idx];
        case BUF_B:     return ShadowMask_dbB[idx];
        case BUF_SHARP: return SharpShadowMask[idx];
        case BUF_RIM:   return RimLightMask[idx];
        default:        return 0.0;
    }
}

float bilinearSampleLow(float2 lowPos, uint kind)
{
    lowPos = ClampToLowGrid(lowPos);

    int2 p0 = (int2)floor(lowPos);
    float2 f = frac(lowPos);

    int2 p1 = p0 + int2(1, 0);
    int2 p2 = p0 + int2(0, 1);
    int2 p3 = p0 + int2(1, 1);

    p0 = ClampToLowCoord(p0);
    p1 = ClampToLowCoord(p1);
    p2 = ClampToLowCoord(p2);
    p3 = ClampToLowCoord(p3);

    float s00 = ReadLow((uint2)p0, BUF_A * 0u + kind);
    float s10 = ReadLow((uint2)p1, kind);
    float s01 = ReadLow((uint2)p2, kind);
    float s11 = ReadLow((uint2)p3, kind);

    float sx0 = lerp(s00, s10, f.x);
    float sx1 = lerp(s01, s11, f.x);
    return lerp(sx0, sx1, f.y);
}

// Map FULL pixel id -> continuous LOW pixel space (centers align).
float2 fullPxToLowPos(uint2 pxFull)
{
    float2 scale = (float2)ShadowResolution / (float2)Resolution;
    return ((float2)pxFull + 0.5) * scale - 0.5;
}

// ---------------------------
// Apply to FULL-RES output
// ---------------------------

inline void ApplyCommon(uint2 px, float2 lowPos, float shadow)
{
    float light = 1.0 - shadow;

    // Medium classification at full-res:
    // s < 0 => spring (no shadows, no rim)
    // 0 < s < 1 => fluid/gas
    // s >= 1 => rigid
    float sFull = ShadowSrcFullRes[GetPixelKeyFull(px)];
    bool insideSpringFull   = (sFull < 0.0);
    bool insideFluidGasFull = (sFull > 0.0) && (sFull < 1.0 - 1e-6);
    bool insideRBFull       = (sFull >= 1.0 - 1e-6);
    bool allowRimHere       = !insideSpringFull && (insideFluidGasFull || insideRBFull);

    float rim = 0.0;
    #if APPLY_RIM_LIGHTING
    if (allowRimHere)
    {
        rim = bilinearSampleLow(lowPos, BUF_RIM);
    }
    #endif

    float4 src  = Result[px];
    float3 base = src.rgb;
    if (!insideSpringFull) base *= light;

    float3 combinedCol = saturate(base + rim);
    PPResult[px] = float4(combinedCol, src.a);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplySharpShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideFullDims(px)) return;

    float2 lowPos = fullPxToLowPos(px);
    float shadow  = bilinearSampleLow(lowPos, BUF_SHARP);
    ApplyCommon(px, lowPos, shadow);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyBlurredShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideFullDims(px)) return;

    float2 lowPos = fullPxToLowPos(px);
    uint   buf    = StepBufferCycle ? BUF_B : BUF_A;
    float  shadow = bilinearSampleLow(lowPos, buf);
    ApplyCommon(px, lowPos, shadow);
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyWithoutShadows(uint3 id : SV_DispatchThreadID)
{
    uint2 px = id.xy;
    if (IsOutsideFullDims(px)) return;
    PPResult[px] = Result[px];
}

// ---------------------------
// Anti-aliasing
// ---------------------------

static const float3 LUMA = float3(0.299, 0.587, 0.114);

float3 ReadAA_rgb(int2 p)
{
    p.x = clamp(p.x, 0, (int)Resolution.x - 1);
    p.y = clamp(p.y, 0, (int)Resolution.y - 1);
    return AAInput.Load(int3(p,0)).rgb;
}

float  ReadAA_a(int2 p)
{
    p.x = clamp(p.x, 0, (int)Resolution.x - 1);
    p.y = clamp(p.y, 0, (int)Resolution.y - 1);
    return AAInput.Load(int3(p,0)).a;
}

[numthreads(TN_PP2, TN_PP2, 1)]
void ApplyAA(uint3 id : SV_DispatchThreadID)
{
    uint2 upx = id.xy;
    if (IsOutsideFullDims(upx)) return;

    int2 p = int2(upx);

    float3 c  = ReadAA_rgb(p);
    float3 cN = ReadAA_rgb(int2(p.x, p.y - 1));
    float3 cS = ReadAA_rgb(int2(p.x, p.y + 1));
    float3 cW = ReadAA_rgb(int2(p.x - 1, p.y));
    float3 cE = ReadAA_rgb(int2(p.x + 1, p.y));

    float lC = dot(c , LUMA);
    float lN = dot(cN, LUMA);
    float lS = dot(cS, LUMA);
    float lW = dot(cW, LUMA);
    float lE = dot(cE, LUMA);

    float gradH = abs(lW - lE);
    float gradV = abs(lN - lS);
    float edge  = max(gradH, gradV);

    float blend = saturate((edge - AAThreshold) / (1.0 - AAThreshold)) * AAMaxBlend;

    // Directional 3-tap blur along minor gradient axis
    float3 blurH = (cW + c + cE) * (1.0/3.0);
    float3 blurV = (cN + c + cS) * (1.0/3.0);
    float3 aaCol = (gradH > gradV) ? blurV : blurH;

    float3 outCol = lerp(c, aaCol, blend);
    float  outA   = ReadAA_a(p); // preserve alpha

    AAOutput[upx] = float4(outCol, outA);
}

[numthreads(TN_PP2,TN_PP2,1)]
void CopyResultToPP(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    PPResult[id.xy] = Result[id.xy];
}

// Instead of the current rim lighting, use the sunDir in_ renderer to apply an effect near the edges pacing the sun.
// Also, make the edges of all rbs appear curved, like rounded edges on a cube. To achieve this_, add functionality for_ both altering the uv, and calculating a normal and comparing it to the sunDir. Make the sunDir a float3_ so it can shine ON the rigidbodies.
// All added variables/settings should be defined with static_ const_ variables in_ the shader _(not set from c#).